#!/bin/bash
# SPDX-License-Identifier: LGPL-2.1-or-later
#
# End of first stage of build:
# - built UKI is in $OUTPUTDIR
# - get PCR policy digests if any, or PE hash(es) with systemd-sbsign
# - pack them up in a cpio as OBS expects and store them in OTHER/
# - create minimal recipe for second stage that will continue from here

set -e

declare -a UKIS
mapfile -t UKIS < <(find "$OUTPUTDIR" -type f -name "*.efi" -printf '%P\n')
declare -a KERNELS
mapfile -t KERNELS < <(find "$OUTPUTDIR" -type f -name "vmlinu*" -printf '%P\n')
declare -a ROOTHASHES
mapfile -t ROOTHASHES < <(find "$OUTPUTDIR" -type f -name "*.roothash" -printf '%P\n')
declare -a DDIS
mapfile -t DDIS < <(find "$OUTPUTDIR" -type f -name "*.raw*")

if ((${#UKIS[@]} == 0)) && ((${#KERNELS[@]} == 0)) && ((${#ROOTHASHES[@]} == 0)) && ((${#DDIS[@]} == 0)); then
    echo "No unsigned files found, exiting"
    exit 0
fi

# When a single build has multiple images, postoutput is called for each image,
# so make sure the hashes.cpio from the previous stages gets its content preserved
if [ -f /usr/src/packages/OTHER/hashes.cpio.rsasign ]; then
    pushd hashes
    cpio -idm </usr/src/packages/OTHER/hashes.cpio.rsasign
    popd
fi

for f in "${UKIS[@]}"; do
    test -f "${OUTPUTDIR}/${f}" || continue
    if [ -f "${OUTPUTDIR}/${f%.efi}.pcrs" ]; then
        mkdir -p "hashes/pcrs/$f"
        while read -r pol; do
            echo -n "$pol" | tr '[:lower:]' '[:upper:]' | basenc --base16 --decode >"hashes/pcrs/${f}/${pol}"
        done < <(jq -r 'to_entries[] | .value[].pol' <"${OUTPUTDIR}/${f%.efi}.pcrs")
    else
        mkdir -p "$(dirname "hashes/ukis/$f")"
        systemd-sbsign \
            sign \
            --certificate /usr/src/packages/SOURCES/_projectcert.crt \
            --output "hashes/ukis/$f" \
            --prepare-offline-signing \
            "${OUTPUTDIR}/${f}"
    fi
done

for f in "${KERNELS[@]}"; do
    test -f "${OUTPUTDIR}/${f}" || continue
    mkdir -p "$(dirname "hashes/kernels/$f")"
    systemd-sbsign \
        sign \
        --certificate /usr/src/packages/SOURCES/_projectcert.crt \
        --output "hashes/kernels/$f" \
        --prepare-offline-signing \
        "${OUTPUTDIR}/${f}"
done

repart_dir="$(jq -r '.RepartDirectories[-1]' "$MKOSI_CONFIG")"
for f in "${ROOTHASHES[@]}"; do
    test -f "${OUTPUTDIR}/${f}" || continue
    mkdir -p hashes/roothashes
    cp "${OUTPUTDIR}/$f" hashes/roothashes/
    # If we have a DDI to operate on, we need the repart definitions, so save the configs across to the next stage
    if [ "$repart_dir" != "null" ]; then
        pushd "$repart_dir" 2>/dev/null
        tar cf "$OUTPUTDIR/${f%roothash}repart.tar" ./*
        popd 2>/dev/null
    fi
done

# Handle bootloaders separately from UKIs
for ddi in "${DDIS[@]}"; do
    test -f "$ddi" || continue
    if [[ $ddi == *.zst ]]; then
        unzstd "${ddi}"
    fi
    offset="$(systemd-repart --json=short "${ddi%.zst}" | jq -r '.[] | select(.type == "esp") | .offset')"
    if [ "$offset" = "null" ]; then
        if [[ $ddi == *.zst ]]; then
            rm -f "${ddi%.zst}"
        fi
        continue
    fi

    rm -rf EFI
    mcopy -s -i "${ddi%.zst}@@${offset}" ::EFI EFI || true
    find EFI

    # UKIs are handled separately
    rm -rf EFI/Linux

    while read -r BOOTLOADER; do
        mkdir -p "hashes/bootloaders/$(basename "${ddi%.zst}")/$(dirname "$BOOTLOADER")"
        systemd-sbsign \
            sign \
            --certificate /usr/src/packages/SOURCES/_projectcert.crt \
            --output "hashes/bootloaders/$(basename "${ddi%.zst}")/$BOOTLOADER" \
            --prepare-offline-signing \
            "$BOOTLOADER"
    done < <(find EFI -type f -iname '*.efi')

    if [[ $ddi == *.zst ]]; then
        rm -f "${ddi%.zst}"
    fi
    rm -rf EFI
done

# If there is at least one DDI then there might be an ESP, so prepare the authvars for self-enrollment
if ((${#DDIS[@]} > 0)); then
    mkdir -p hashes/authvars
    pushd hashes/authvars 2>/dev/null

    for db in PK KEK db; do
        systemd-sbsign \
            sign-secure-boot-database \
            --certificate /usr/src/packages/SOURCES/_projectcert.crt \
            --secure-boot-database "$db" \
            --output "$db.auth" \
            --prepare-offline-signing
    done

    popd 2>/dev/null
fi

# Pack everything into a CPIO archive and place it where OBS expects it
pushd hashes
find . -type f | cpio -H newc -o >"$OUTPUTDIR/hashes.cpio.rsasign"
popd
rm -rf hashes

echo "Staging the following files for signing:"
cpio -t <"$OUTPUTDIR/hashes.cpio.rsasign"

# The second stage will not do a full rebuild, but only attach signatures to the existing UKI
cat >"$OUTPUTDIR/mkosi.conf" <<EOF
[Distribution]
Distribution=custom
[Output]
Format=none
ImageId=$IMAGE_ID
[Include]
Include=mkosi-obs
[Build]
BuildSources=/usr/src/packages/OTHER:/usr/src/packages/OTHER
EOF
